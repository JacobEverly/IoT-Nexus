from "hashes/poseidon/poseidon" import ark;
from "hashes/poseidon/poseidon" import sbox;
from "hashes/poseidon/poseidon" import mix;
from "hashes/poseidon/poseidon" import POSEIDON_C;
from "hashes/poseidon/poseidon" import POSEIDON_M;

struct Message {
    field message;
}

struct Commitment {
    field attester_root;
    u32 proven_weight;
}

struct Signature {
    field r;
    field s;
}

struct MapT {
    u32 index;
    u32 tree_size;
    Signature signature;
    u32 left_weight;
    field[3] sig_merkle_proof;
    field public_key;
    u32 attester_weight;
    field[3] attester_merkle_proof;
}

struct Certificate {
    field signature_root;
    u32 signed_weight;
    MapT[2] map_t;
}

const BabyJubJubParams BABYJUBJUB_PARAMS = BabyJubJubParams {
    // Order of the curve for reference: 21888242871839275222246405745257275088614511777268538073601725287587578984328
    JUBJUB_C: 8, // Cofactor
    JUBJUB_A: 168700, // Coefficient A
    JUBJUB_D: 168696, // Coefficient D

    // Montgomery parameters
    MONT_A: 168698,
    MONT_B: 1,

    // Point at infinity
    INFINITY: [0, 1],

    // Generator
    // Gu: 16540640123574156134436876038791482806971768689494387082833631921987005038935,
    // Gv: 20819045374670962167435360035096875258406992893633759881276124905556507972311
    Gu: 995203441582195749578291179787384436505546430278305826713579947235728471134,
    Gv: 5472060717959818805561601436314318772137091100104008585924551046643952123905
};

def poseidon(field msg) -> field {
    u32 t = 3;
    u32 alpha = 3;
    u32 full = 8;
    u32 partial = 57;
    field[3] mut state = [msg, 1, 2];

    u32 mut round = 0;

    field[497]  constants = POSEIDON_C[t - 2];
    field[7][7] mds = POSEIDON_M[t - 2];

    for u32 round in 0..full + partial {
        state = ark(state, constants, round * t);
        state = sbox(state, full, partial, round);
        state = mix(state, mds);
    }

    return state[0];
}


def create_commitment<N>(field commitment, u32 index, field[N] proof) -> bool {
    field mut current_hash = proof[0];
    u32 mut shift = N;
    for u32 i in 1..N {
        shift = shift - 1;
        current_hash = if (index & (1 << (shift))) == 0 {
            poseidon(current_hash + proof[i])
        } else {
            poseidon(proof[i] + current_hash)
        };
    }
    return commitment == current_hash;
}

def verify_merkle_proof<N>(field commitment, u32 index, field[N] proof) -> bool {
    assert(N > 0);

    bool res = if N < 2 {
        commitment == proof[0]
    } else {
        create_commitment(commitment, index, proof)
    };
    return res;
}

def verify_coin(
    field proven_weight, 
    field signature_root, 
    field attester_root,
    u32[16] message,
    u32 num_reveals,
    Attester attester, 
    Signature signature, 
    u32 left_weight, 
    field[32] signature_siblings, 
    field[32] attester_siblings
    MapT[1000] map_t,
) -> bool {
    for i in 0..num_reveals {
        hin = [i, signature_root, proven_weight, message, attester_root];
        coin = poseidon(hin) % (signed_weight - 1) + 1;

        for j in 0..map_t.length {
            MapT t = map_t[i];
            Attester t_attester = t.attester;
            u32 t_left_weight = t.left_weight;
            Signature t_signature = t.signature;
            field[depth] t_signature_siblings = t.signature_siblings;
            field[depth] t_attester_siblings = t.attester_siblings;

            if t_left_weight < coin && coin <= t_left_weight + attester.weight {
                if t_attester == attester && t_attester_siblings == attester_siblings && t_signature == signature && t_signature_siblings == signature_siblings {
                    return true;
                }
            }
        }
    }
    return false;
}

def main(
    Message msg, 
    Commitment commitment, 
    private Certificate certificate //private variable must be used in main function
    ) -> bool {
        bool mut res = false;

        // check signed weight overpass the threshold
        res = certificate.signed_weight < commitment.proven_weight? false : true;
        assert(res);

        // verify merkle path
        for u32 i in 0..2 {
            MapT t = certificate.map_t[i];
            res = verify_merkle_proof(certificate.signature_root, t.index, t.sig_merkle_proof);
            assert(res);
            res = verify_merkle_proof(commitment.attester_root, t.index, t.attester_merkle_proof);
            assert(res);
        }

        // verify signature

        assert(certificate.signature_root != commitment.attester_root);
        assert(certificate.map_t[0] != certificate.map_t[1]);
        return res;
    }

// zokrates compute-witness --abi -i --stdin --verbose < verify.json